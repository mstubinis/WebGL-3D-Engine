<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>WebGL Engine</title>
    <style>
    html,head,body{margin:0;outline:0;border:0;padding:0;overflow:hidden;left:0;top:0;position:absolute;z-index:1;}
    </style>
    <script src="deps/gl-matrix.js"> </script>
    <script src="deps/webgl-utils.js"></script>
    <script src="deps/OBJLoader.js"></script>

    <script src="core/Engine_ResourceManager.js"></script>
    <script src="core/Engine_GBuffer.js"></script>
    <script src="core/Engine_RenderManager.js"></script>
    <script src="core/Engine_ObjectManager.js"></script>
    <script src="core/Engine_EventManager.js"></script>
    <script src="core/Engine_Core.js"></script>
    
	<script src="core/scene.js"></script>
    <script src="core/shader.js"></script>
    <script src="core/mesh.js"></script>
    <script src="core/texture.js"></script>
    <script src="core/material.js"></script>
    <script src="core/camera.js"></script>
    <script src="core/object.js"></script>
    <script src="core/skybox.js"></script>
    <script src="core/light.js"></script>
    
    <script src="game.js"></script>
     
    <script id="vshader" type="x-shader/x-vertex">
        attribute vec3 position;
        attribute vec2 uv;
        attribute vec3 normal;
        attribute vec3 binormal;
        attribute vec3 tangent;

        uniform mat4 M;
        uniform mat4 V;
        uniform mat4 P;
        uniform mat4 normalMatrix;
		
		varying vec2 UV;
		varying vec4 Part1; //Normals and Binormal.x
		varying vec4 Part2; //Binormal.y Binormal.z Tangent.x Tangent.y
		varying vec4 Part3; //Tangent.z World Position
        void main(void){
            vec3 Normal = normalize(normalMatrix * vec4(normal,1.0)).xyz;
            vec3 Binormal = normalize(normalMatrix * vec4(binormal,1.0)).xyz;
            vec3 Tangent = normalize(normalMatrix * vec4(tangent,1.0)).xyz;
			
            //vec3 Normal = normalize(mat3(normalMatrix) * normal);
            //vec3 Binormal = normalize(mat3(normalMatrix) * binormal);
            //vec3 Tangent = normalize(mat3(normalMatrix) * tangent);
			
			vec3 WorldPosition = (M * vec4(position,1.0)).xyz;

			UV = uv;
			Part1 = vec4(Normal.xyz,Binormal.x);
			Part2 = vec4(Binormal.y,Binormal.z,Tangent.x,Tangent.y);
			Part3 = vec4(Tangent.z,WorldPosition.xyz);

            gl_Position =  (P * V * M) * vec4(position,1.0);
        }
    </script>
    <script id="fshader" type="x-shader/x-fragment">
        precision mediump float;

        uniform sampler2D diffuseMap;
        uniform sampler2D glowMap;
        uniform sampler2D normalMap;
        
		uniform vec3 LightAttenuation;
        uniform vec3 LightPosition;
        uniform vec3 LightColor;
        
        //x = ambientPower | y = DiffusePower | z = SpecularPower | w = LightW
        uniform vec4 LightProperties;
        
		uniform vec3 SceneAmbient;
		
        uniform vec4 MaterialColor;       //rgb is color. a is transparency
		uniform vec4 MaterialSpecularity; //rgb is color. a is shininess
		
        uniform vec3 CameraPosition;
		
		varying vec2 UV;
		varying vec4 Part1; //Normals and Binormal.x
		varying vec4 Part2; //Binormal.y Binormal.z Tangent.x Tangent.y
		varying vec4 Part3; //Tangent.z World Position
        vec3 CalcBumpedNormal(vec3 unpackedNormals){
            vec3 normalMapTexture = (texture2D(normalMap, UV).xyz) * 2.0 - 1.0;	
			vec3 unpackedBinormals = vec3(Part1.w,Part2.x,Part2.y);
			vec3 unpackedTangents = vec3(Part2.z,Part2.w,Part3.x);
            mat3 TBN = mat3(unpackedTangents, unpackedBinormals, unpackedNormals);
            return normalize(TBN * normalMapTexture);
        }
		vec4 CalcLightInternal(vec3 SurfaceToLight,vec3 SurfaceNormal,vec3 SurfacePosition){
			vec3 AmbientColor = LightProperties.x * SceneAmbient;
			vec3 LightingFinal = AmbientColor;
			float nDotL = max(0.0, dot(SurfaceNormal, SurfaceToLight));
			if(nDotL > 0.0){
				vec3 DiffuseColor = nDotL * (MaterialColor.rgb * LightProperties.y);
			    vec3 ViewVector = -normalize(SurfacePosition - CameraPosition);
				// this is blinn phong
				vec3 HalfVector = normalize(SurfaceToLight + ViewVector);
				float SpecularAngle = max(dot(HalfVector, SurfaceNormal), 0.0);
				SpecularAngle = pow(SpecularAngle, MaterialSpecularity.w);
				vec3 SpecularColor = MaterialSpecularity.rgb * LightProperties.z * SpecularAngle;
				LightingFinal += (DiffuseColor + SpecularColor);
			}
			return vec4(LightingFinal,MaterialColor.w);
		}
		
        void main(void){
			vec4 diffuseTexture = texture2D(diffuseMap,UV);
			vec4 glowTexture = vec4(texture2D(glowMap,UV).r);
			vec3 SurfacePosition = Part3.yzw;

            //vec3 SurfaceNormal = CalcBumpedNormal(Part1.xyz);
            vec3 SurfaceNormal = normalize(Part1.xyz);

			vec4 lighting = vec4(0.0);
			if(LightProperties.w == 0.0) {//directional light
				lighting = CalcLightInternal(normalize(LightPosition),SurfaceNormal,SurfacePosition);
			} 
			else {//point light
				vec3 SurfaceToLight = normalize(LightPosition - SurfacePosition);
				lighting = CalcLightInternal(SurfaceToLight,SurfaceNormal,SurfacePosition);
				float D = length(LightPosition - SurfacePosition);
				float Att = max(1.0 , LightAttenuation.x + (LightAttenuation.y * D) + (LightAttenuation.z * D * D));
				
				//cone restrictions (affects attenuation)
				//float lightToSurfaceAngle = degrees(acos(dot(-SurfaceToLight, normalize(light.coneDirection))));
				//if(lightToSurfaceAngle > light.coneAngle){
					//Att = 0.0;
				//}
				lighting /= Att;
			}	
            gl_FragColor = max(lighting,glowTexture) * diffuseTexture;
			gl_FragColor.a = lighting.a * diffuseTexture.a;
        }
    </script>   
</head>
<body style = "background-color:black;">
    <script>
    function getParamValue(paramName){
        var url = window.location.search.substring(1);
        var array = url.split('&');
        for (var i = 0; i < array.length; i++){
            var pArr = array[i].split('=');
            if (pArr[0] == paramName) 
                return pArr[1];
        }
    }
    function init(){
        var w = Math.floor(window.innerWidth * 1.0);
        var h = Math.floor(window.innerHeight * 1.0);
        Engine.init( w,h );
    }
    window.onload = init;
    </script>
</body>
</html>
