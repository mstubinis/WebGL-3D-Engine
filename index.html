<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>WebGL Engine</title>
    <style>
    html,head,body{margin:0;outline:0;border:0;padding:0;overflow:hidden;left:0;top:0;position:absolute;z-index:1;}
    </style>
    <script src="deps/gl-matrix.js"> </script>
    <script src="deps/webgl-utils.js"></script>
    <script src="deps/OBJLoader.js"></script>

    <script src="core/Engine_ResourceManager.js"></script>
    <script src="core/Engine_GBuffer.js"></script>
    <script src="core/Engine_RenderManager.js"></script>
    <script src="core/Engine_ObjectManager.js"></script>
    <script src="core/Engine_EventManager.js"></script>
    <script src="core/Engine_Core.js"></script>
    
	<script src="core/scene.js"></script>
    <script src="core/shader.js"></script>
    <script src="core/mesh.js"></script>
    <script src="core/texture.js"></script>
    <script src="core/material.js"></script>
    <script src="core/camera.js"></script>
    <script src="core/object.js"></script>
    <script src="core/skybox.js"></script>
    <script src="core/light.js"></script>
    
    <script src="game.js"></script>
     
    <script id="vshader" type="x-shader/x-vertex">
        attribute vec3 position;
        attribute vec2 uv;
        attribute vec3 normal;
        attribute vec3 binormal;
        attribute vec3 tangent;

        uniform mat4 M;
        uniform mat4 V;
        uniform mat4 P;
        //uniform mat4 normalMatrix;
		
		varying vec2 UV;
		varying vec4 Part1; //Normals and Binormal.x
		varying vec4 Part2; //Binormal.y Binormal.z Tangent.x Tangent.y
		varying vec4 Part3; //Tangent.z World Position
        void main(void){
            vec3 Normal = normalize((V*M) * vec4(normal, 0.0)).xyz;
            vec3 Binormal = normalize((V*M) * vec4(binormal, 0.0)).xyz;
            vec3 Tangent = normalize((V*M) * vec4(tangent, 0.0)).xyz;
            //vec3 Normal = normalize((normalMatrix) * vec4(normal, 1.0)).xyz;
            //vec3 Binormal = normalize((normalMatrix) * vec4(binormal, 1.0)).xyz;
            //vec3 Tangent = normalize((normalMatrix) * vec4(tangent, 1.0)).xyz;
			
			vec3 WorldPosition = (M * vec4(position,1.0)).xyz;
			
			UV = uv;
			Part1 = vec4(Normal.xyz,Binormal.x);
			Part2 = vec4(Binormal.y,Binormal.z,Tangent.x,Tangent.y);
			Part3 = vec4(Tangent.z,WorldPosition.xyz);

            gl_Position =  (P * V * M) * vec4(position,1.0);
        }
    </script>
    <script id="fshader" type="x-shader/x-fragment">
        precision mediump float;

        uniform sampler2D diffuseMap;
        uniform sampler2D glowMap;
        uniform sampler2D normalMap;
        
		uniform vec3 LightAttenuation;
        uniform vec3 LightPosition;
        uniform vec3 LightColor;
        
        //x = ambientPower | y = DiffusePower | z = SpecularPower | w = LightW
        uniform vec4 LightProperties;
        
        uniform vec4 MaterialSpecular;
        
        uniform vec3 CameraPosition;

		varying vec2 UV;
		varying vec4 Part1; //Normals and Binormal.x
		varying vec4 Part2; //Binormal.y Binormal.z Tangent.x Tangent.y
		varying vec4 Part3; //Tangent.z World Position
        vec4 CalcLightInternal(vec3 LightDir,vec3 PxlWorldPos,vec3 PxlNormal){
            vec4 AmbientColor = vec4(LightColor, 1.0) * LightProperties.x;
            float Lambertian = max(dot(LightDir,PxlNormal), 0.0);
            vec4 DiffuseColor  = vec4(0.0);
            vec4 SpecularColor = vec4(0.0);
            vec4 lightWithoutSpecular = vec4(0.0);
            if (Lambertian > 0.0) {
                DiffuseColor = vec4(LightColor, 1.0) * LightProperties.y * Lambertian;
                vec3 ViewVector = normalize(-PxlWorldPos - CameraPosition);

                // this is blinn phong
                vec3 halfDir = normalize(LightDir + ViewVector);
                float SpecularAngle = max(dot(halfDir, PxlNormal), 0.0);
                SpecularAngle = pow(SpecularAngle, LightProperties.z);
                if (SpecularAngle > 0.0 && LightProperties.z > 0.001) {
                    SpecularColor = (vec4(LightColor, 1.0) * MaterialSpecular * SpecularAngle);
                }
                lightWithoutSpecular = (AmbientColor + DiffuseColor);
                lightWithoutSpecular += SpecularColor;
            }
            else{
                lightWithoutSpecular = AmbientColor;
            }
            return lightWithoutSpecular;
        }
        vec4 CalcPointLight(vec3 PxlWorldPos, vec3 PxlNormal){
            vec3 LightDir = LightPosition - PxlWorldPos;
            float Distance = length(LightDir);
            LightDir = normalize(LightDir);

            vec4 c = CalcLightInternal(LightDir, PxlWorldPos, PxlNormal);

            float a =  max(1.0 , LightAttenuation.x + (LightAttenuation.y * Distance) + (LightAttenuation.z * Distance * Distance));
            return c / a;
        }
        vec3 CalcBumpedNormal(vec3 unpackedNormals){
            vec3 normalMapTexture = (texture2D(normalMap, UV).xyz) * 2.0 - 1.0;
			
			vec3 unpackedBinormals = vec3(Part1.w,Part2.x,Part2.y);
			vec3 unpackedTangents = vec3(Part2.z,Part2.w,Part3.x);
			
            mat3 TBN = mat3(unpackedTangents, unpackedBinormals, unpackedNormals);
            return normalize(TBN * normalMapTexture);
        }

        void main(void){
            vec3 diffuseMapColor = texture2D(diffuseMap,UV).rgb;
            float glowMapValue = texture2D(glowMap,UV).r;
            
			vec3 unpackedNormals = Part1.xyz;
			vec3 WorldPosition = Part3.yzw;
			
            //vec3 PxlNormal = CalcBumpedNormal(unpackedNormals);
            vec3 PxlNormal = normalize(unpackedNormals);
            
            vec4 lightCalculation = vec4(0.0);
            
            lightCalculation = CalcPointLight(WorldPosition,PxlNormal);

            lightCalculation.a = 1.0;
            gl_FragColor = max(lightCalculation,vec4(glowMapValue)) * vec4(diffuseMapColor,1.0);
        }
    </script>   
</head>
<body style = "background-color:black;">
    <script>
    function getParamValue(paramName){
        var url = window.location.search.substring(1);
        var array = url.split('&');
        for (var i = 0; i < array.length; i++){
            var pArr = array[i].split('=');
            if (pArr[0] == paramName) 
                return pArr[1];
        }
    }
    function init(){
        var w = Math.floor(window.innerWidth * 1.0);
        var h = Math.floor(window.innerHeight * 1.0);
        Engine.init( w,h );
    }
    window.onload = init;
    </script>
</body>
</html>
